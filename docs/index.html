<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'>
	<title>Simple Clip Editor</title>
	<meta name='viewport' content='width=device-width, initial-scale=1'>
	<script src="deps/vue.js"></script>

<style>
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
	padding: 0;
}
.fill {
	width: 100%;
	height: 100%;
	overflow: hidden;
}
#app {
	display: grid;
	grid-template: 84px auto 32px / auto;
}
header {
	display: grid;
}
main {
	display: grid;
	grid-template: auto / 480px auto;
}

#timeline {
	display: grid;
	grid-template: min-content auto min-content / auto;
}
#timeline>ul {
	display: flex;
	flex-direction: column;
	margin: 0;
	padding: 0;
}
#timeline>ul>li {
	display: grid;
	grid-template: 22px 22px / 300px 100px 80px;
	grid-template-areas:
		"name from dup"
		"name to   rem";
	align-items: center;
	margin: 0;
	padding: 0;
	cursor: pointer;
}
#timeline>ul>li.active {
	background-color: lightblue;
}
#timeline>ul>li>.time {
	justify-self: right;
}
#timeline>ul>li>.time>span:first-child {
	color: grey;
}
#timeline>ul>li>.splice {
	visibility: hidden;
}
#timeline>ul>li:hover>.splice {
	visibility: visible;
}

#preview {
	display: grid;
}
#preview > .preview--clip {
	display: none;
}
#preview > .preview--clip.active {
	display: grid;
}
#preview > .preview--clip > video {
	object-fit: contain;
}
#preview > .preview--clip > .preview--setTime {
	display: flex;
	justify-content: space-between;
}
</style>
</head>
<body id="app">
	<header>
		<h1>Simple Clip Editor</h1>
	</header>
	<main class="fill">
		<div id="timeline" class="fill">
			<div>Timeline</div>
			<ul>
				<li v-for="clip in clips" :key="clip.key" @click="selectPreview(clip.key)" :class="{'active': previewKey === clip.key}">
					<div class="name" style="grid-area: name">{{ clip.name }}</div>
					<div class="time" style="grid-area: from"><span>from </span><span>{{ renderTime(clip.startTime) }}</span></div>
					<div class="time" style="grid-area: to"><span>to </span><span>{{ renderTime(clip.endTime) }}</span></div>
					<button class="splice" style="grid-area: dup" @click="duplicateClip(clip.key)">Duplicate</button>
					<button class="splice" style="grid-area: rem" @click="removeClip(clip.key)">Remove</button>
				</li>
			</ul>
		</div>
		<div id="preview" class="fill">
			<div v-for="clip in clips" :key="clip.key" class="preview--clip fill" :class="{'active': previewKey === clip.key}">
				<video :src="clip.url" controls muted :ref="setVideoRef(clip)" v-on:loadedmetadata="setMetadata(clip)" class="fill"></video>
				<div class="preview--setTime">
					<span><input type="text" :value="renderTime(clip.startTime)" readonly><button @click="setStartTime(clip)"><-</button></span>
					<span><input type="text" :value="renderTime(clip.endTime - clip.startTime)" readonly></span>
					<span><button @click="setEndTime(clip)">-></button><input type="text" :value="renderTime(clip.endTime)" readonly></span>
				</div>
			</div>
		</div>
	</main>
	<div><label>Add Video Files...<input ref="videoFileInput" type="file" accept="video/*" multiple hidden @input="addClip"></label></div>
</body>
<script>
let app = {
	el: '#app',
	data() {
		return {
			// Clip currently being previewed
			// If out of bounds then no preview is selected
			previewKey: 0,
			// Unique key for the next clip added
			nextKey: 0,
			// List of clips on the timeline
			// See `addClip` for the child object structure
			clips: [],
		};
	},
	methods: {
		renderTime(time) {
			let msecs = Math.floor((time - Math.floor(time)) * 1000);
			let secs = Math.floor(time % 60);
			let mins = Math.floor(time / 60);
			let hours = Math.floor(time / 3600);
			let tail = secs.toString().padStart(2, "0") + "." + msecs.toString().padStart(3, "0");
			return hours == 0 ?
				"" + mins + ":" + tail :
				"" + hours + ":" + mins.toString().padStart(2, "0") + ":" + tail;
		},
		addClip(e) {
			let files = e.target.files;
			for (let i = 0; i < files.length; i += 1) {
				let file = files[i];
				let clip = {
					key: this.nextKey++,
					name: file.name,
					startTime: 0,
					endTime: 0,
					url: URL.createObjectURL(file),
					videoRef: null, // Filled in later in `setVideoRef`
				};
				if (i == 0) {
					this.previewKey = clip.key;
				}
				this.clips.push(clip);
			}
		},
		setVideoRef(clip) {
			return videoRef => {
				clip.videoRef = videoRef;
			};
		},
		setMetadata(clip) {
			clip.endTime = clip.videoRef.duration;
		},
		setStartTime(clip) {
			clip.startTime = clip.videoRef.currentTime;
			if (clip.startTime > clip.endTime) {
				clip.endTime = clip.videoRef.currentTime;
			}
		},
		setEndTime(clip) {
			clip.endTime = clip.videoRef.currentTime;
			if (clip.endTime < clip.startTime) {
				clip.startTime = clip.videoRef.currentTime;
			}
		},
		removeClip(key) {
			let index = this.clips.findIndex(clip => clip.key == key);
			// FIXME! Leaking object URL here...
			// Multiple clips can refer to the same object URL so they need to be reference counted
			this.clips.splice(index, 1);
			// Move the current preview to the next clip (if any)
			if (index < this.clips.length) {
				this.previewKey = this.clips[index].key;
			}
			else if (index > 0) {
				this.previewKey = this.clips[index - 1].key;
			}
		},
		duplicateClip(key) {
			let index = this.clips.findIndex(clip => clip.key == key);
			let clip = this.clips[index];
			let newClip = {
				key: this.nextKey++,
				name: clip.name,
				startTime: clip.startTime,
				endTime: clip.endTime,
				url: clip.url,
				videoRef: null, // Filled in later in `setVideoRef`
			};
			this.previewKey = newClip.key;
			this.clips.splice(index + 1, 0, newClip);
		},
		pauseAll() {
			for (let i = 0; i < this.clips.length; i += 1) {
				let clip = this.clips[i];
				if (clip.videoRef) {
					clip.videoRef.pause();
				}
			}
		},
		selectPreview(key) {
			if (key != this.previewKey) {
				// Pause all running video players when switching
				this.pauseAll();
				this.previewKey = key;
			}
		},
	},
};
Vue.createApp(app).mount('#app');
</script>
</html>
